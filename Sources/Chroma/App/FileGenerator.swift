//
//  FileGenerator.swift
//  Chroma
//
//  Created by Jota Uribe on 16/10/23.
//

import Files
import Foundation

struct FileGenerator {
    private static let colorAssetExtension = "colorset"
    
    let asset: String
    let path: String
    let type: OutputType
    let framework: Framework
    
    func generate() throws -> File {
        let outputFile = try createOutputFile()
        let content = try getContentFromAssetsFile(outputFile: outputFile)
        try outputFile.write(content)
        return outputFile
    }
    
    // MARK: Helper Methods
    
    private func createOutputFile() throws -> File {
        // Check if path param is a valid swift file path
        guard let pathURL = URL(string: path), !pathURL.hasDirectoryPath, pathURL.pathExtension == "swift"  else {
            throw ChromaError.invalidPath(path: path)
        }
        
        let folder = try Folder(path: pathURL.deletingLastPathComponent().path)
        return try File(named: pathURL.lastPathComponent, at: folder)
    }
    
    private func getContentFromAssetsFile(outputFile: File) throws -> String {
        let assetFolder = try Folder(path: asset)
        let body = fileBody(asset: assetFolder).joined(separator: "\n")
        return fileContent(header: header(fileName: outputFile.nameExcludingExtension), body: body)
    }
    
    func fileContent(header: String, body: String) -> String {
        """
        //
        //  Generated by Chroma.
        //  https://github.com/jjotaum/Chroma.
        //
        //  This file was auto generated please do not modify it directly.
        //
        
        import \(framework.rawValue)
        
        \(header) {
        
        \(body)
        
        }
        """
    }
    
    func header(fileName: String) -> String {
        switch type {
        case .extension:
            return "\(type.rawValue) \(framework.variableType)"
        case .struct:
            return "\(type.rawValue) \(fileName.capitalized)"
        }
    }
    
    func fileBody(asset: Folder) -> Array<String> {
        let assetKey = asset.nameExcludingExtension
        // Get subfolders with valid extension
        let colorSubfolders = asset.subfolders.recursive.filter { $0.extension == Self.colorAssetExtension }
        // Group them by parent name to use them as MARK's
        let parents = Dictionary(grouping: colorSubfolders, by: \.parent?.nameExcludingExtension)
        var content: [String] = []
        // Add main variables
        if let root = parents[assetKey] {
            content.append(contentsOf: colorVariableNames(folders: root))
        }
        // Sort keys to give output MARKS alphabetical order
        parents.sorted(by: { $0.key ?? "" < $1.key ?? "" }).forEach { (key, value) in
            guard key != assetKey else { return }
            if let mark = key {
                content.append("    // MARK: - \(mark)")
            }
            // Add MARK variables
            content.append(contentsOf: colorVariableNames(folders: value))
        }
        return content
    }
    
    private func colorVariableNames(folders: [Folder]) -> [String] {
        // We filter out duplicated variable names
        Set(folders.compactMap { colorFolder in
            return framework.colorVariable(name: colorFolder.nameExcludingExtension)
        }).sorted()
    }
}
